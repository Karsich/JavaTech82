любой программе может случиться ошибка
для этого есть тысяча и одна причина
может быть пользователь ввел
неправильные данные может быть
отвалилась необходимая программе базы
данных или другой важный сетевой ресурс
может быть сбоит чип оперативной памяти
и случайным образом портит данные в нем
хранящиеся
причины могут быть разные но непреложный
факт состоит в том что от всех ошибок не
застраховаться а следовательно нашим
программам приходится иногда с ними
сталкиваться и как-то на них реагировать
разных языках существует разная культура
обработки ошибок определяемая как
возможностями языка платформы так и
исторически сложившимися традициями
чтобы дальнейший рассказ не был слишком
теоретическим давайте рассмотрим такой
пример
предположим вы пишете подключаемую в
разные программы библиотеку вычисляющую
математические выражения лицо этой
библиотеке интерфейс калькулятор и
какая-то его реализация в интерфейсе
есть метод принимающий строку с
выражением и возвращаюсь обратно дабл
вычисленное значение выражения и вот
выражение поданным на вход содержится
ошибка например в нем встречается число
где в качестве от десятичного
разделителя используется , вместо точки
как калькулятору на это реагировать
самой простой по реализации но и самый
плохой по последствиям способ это вызов
system x то есть программа немедленно
завершится упадет по сути потеряв все
накопленные в памяти данные раз и все
нету ни программы не данных я имею ввиду
всю большую программу включающую
калькулятор в качестве одного из своих
компонентов недостатки такого поведения
понятная программа рухнула пользователю
придется ее перезапускать и начинать все
что он делал сначала хорошо еще если
программа сообщает в чем причина ошибки
а то как пользователь догадается что на
самом деле программа упал а потому что
неделю назад он вел где-то число в
неправильном формате
в общем систем оксид это не самое
дружелюбное поведение со стороны нашей
библиотеке калькулятора есть способ
немного получше
случае ошибки выражения наша библиотека
будет возвращать в качестве результата
какое-то специальное значение например
нам по которому вызывающая сторона
поймет что случилась ошибка но нужно
чтобы возвращаемого типа было свободное
значение которое можно зарезервировать
подошли пку
это не всегда возможно например
генератор случайных чисел может
сгенерировать
абсолютно любое число где нам взять
отдельное значение под ошибку а если
видов ошибок несколько их надо различать
то потребуется несколько значений да и в
нашем случае нам может совершенно
законно получится при некоторых
вычислениях например при делении 0 на 0
или при умножении 0 на бесконечность в
общем как обозначить ошибку не понятно а
даже если бы мы выделили какое-то
специальное значение то вызывающий код
некрасиво оброс бы и fame для
своевременного отлова этой ошибки
чтобы обойти проблему с резервированием
значения под ошибка возвращаем им теперь
можно пойти дальше и у метода завести
выходной параметр специально под флаг
ошибки или возвращать из методы не дабл
а простенький объект пару состоящую из
числа результата и признака ошибки
примерно так
тогда весь диапазон типа результата
будет использоваться по своему
назначению
правда и food ли отслеживание ошибки
вызывающем коде никуда не денутся есть
ещё вариант с заведением от признак
ошибки отдельного поля или метода в
самом классе
то есть после вызова метода колки late
вызывающий код должен будет дернуть еще
один метод калькулятора чтобы узнать о
можно ли верить возвращено му только что
результаты очевидно это ещё более
усложняет вызывающий код
а также ставит крест на использование
одного экземпляра калькулятора из
нескольких потоков все эти способы
уведомления частей программы о
случившихся ошибках имеют серьезные
недостатки счастью есть решение которое
их лишено и она состоит в использовании
исключение исключение это событие
которое случается в процессе работы
программы и прерывает стандартный ход ее
исполнения программа переходит
специальный режим поиска обработчика
внештатной ситуации такой обработчик
может предпринять какие то действия и
вернусь программу штатный режим работы
но если обработчика не нашлось тот
живьем все-таки завершит программу но
обеспечит достаточно подробный
диагностический вывод по которому если
не пользователь то хотя бы программист
поймет куда копать исключение поддержаны
на уровне языка java то есть ключевых
слов и синтаксических конструкций
кроме того они используются на уровне
виртуальной машины которая сообщает о
многих своих проблемах бросая исключения
ну и разумеется вся стандартная
библиотека тоже активно использует
исключение приведу несколько самых
популярных исключений какие-то из них вы
наверняка уже получали когда писали свои
первые программы
jalou young anal pointer exception или
java программиста зовут его просто н.п.
это исключение выбрасывается живем когда
идет обращение по нулевой ссылки другими
словами есть переменная ссылочного типа
куда положили на а потом пытаются по
этой ссылке вызвать метод или обратиться
полив в ответ виртуальная машина кинет
такое исключение которое при отсутствии
обработчика приведет к аварийной
остановки и распечатки в консоли
информации об исключении распечатана
будет следующее тип исключения возможно
какое-то сообщение с деталями и stack
trace
вся цепочка вызовов начиная от точки
входа в программу и заканчивая методом
где собственно случилась ошибка здесь же
для каждого метода видно имя исходного
файла и строку в нём другое исключением
эры index out of bounds exception
случается если попытаться обратиться к
несуществующему элементу массива по
отрицательному индексу
или по индексу большим или равному длине
массива аналогичное исключение
string index out of bounds exception
случится если обратиться к
несуществующему символа в строке
исключение java и a file not found
эксепшен случиться при попытке открытия
не существующего файла
она является подклассом более общего
java
оу-оу-оу эксепшен экземпляры которого
бросаются при самых разных ошибках
ввода-вывода исключениями представлены и
разные ошибки самой виртуальной машины
например когда живьем не хватает памяти
на создание нового объекта она бросает
исключение типа out of memory р-р
которые даже можно попытаться обработать
другое дело что обычно делать этого не
стоит потому что в этой ситуации
предпринять что-то разумное довольно
проблематично исключением java это
объект экземпляр какого-то класса все
классы исключений наследуется от джабал
инфра убил который свою очередь
наследуется о том chic
ключевое свойство экземпляров строго его
подклассов возможность быть брошенными
бросание выглядит следующим образом
ключевое слово sraw и за ним любое
выражение типа from apple обычно здесь
просто создается экземпляр нового
исключение важный момент
stack trace который мы увидим в консоль
и при печати такого исключения
определяется тем где был создан
экземпляр исключение они тем откуда она
была выброшена у класса исключения
традиционно есть конструктор принимающий
строку сообщения
это сообщение поясняющая проблему будет
напечатано вместе со stack trace ом
классе срок был объявлен и различные
методы перечислю некоторые из них get me
such возвращает текстовую строку с
описанием проблемы
это та самая строка которую можно было
передать в конструктор и и задачам
упростить диагностику проблемой
объяснить пользователю что именно
произошло хорошая идея не просто
написать все сломалось
подключить подробности например текущее
состояние объекта и параметры метода где
все произошло в случае с калькулятором
которому пришла некорректная строка с
выражением
можно добавить сюда часть выражения с
которой возникли проблемы при разборе
принц stack trace печатает старт рейс
стандартный поток ошибок но если вы
пишете обработчик исключения которые
только и делает что печатает стектрейсы
завершает программу то такое обработчик
можно вообще не писать так как именно
этот живьем сделает и сама если
исключение не найдя обработчика вылетит
из методом may get stack trace
возвращает stack trace
тоже что печатается в консоли виде
массива java объектов стектрейсы элемент
каждый из которых содержит имя класса
имя метода имя файла
номер строки то есть stack trace можно
получить и проанализировать хотя
потребность такая возникает редко дальше
есть метод get коз он возвращает другое
исключение
явившиеся причиной данного или нал если
данное исключение является первичным они
вызвано каким-то другим
если дойдет дело до печати сообщения в
консоль то будет распечатана вся цепочка
исключен коз как и массаж может быть
заданы при создании экземпляра
исключения там есть соответствующий
перегруженный конструктор и еще есть
гейтса пресс этот метод возвращает одно
или более исключений которые мы
заглушили в процессе обработки основного
исключения поясню на примере представим
что мы читаем из файлы и вдруг случилась
ошибка ввода-вывода вылетела исключение
мы начали ее обрабатывать попытались
закрыть файл но тут бац случилось еще
одно исключение потому что файл совсем
плох и даже закрыть его не получается и
того у нас на руках два исключения что с
ними делать как их обрабатывать
существует такое соображение что первое
исключение обычно более важно именно она
описывает первопричину проблемы а все
остальное что случилось потом с высокой
степенью вероятности это последствия
наведен к
поэтому первое исключение точно терять
не следует с другой стороны последующие
исключения могли быть совсем про другое
и не связаны с первым поэтому совсем
игнорировать их тоже не следует именно
для этого существует массив сапр est
исключений одно исключение выбирается в
качестве главного остальные под него
подвешиваются и все это в таком виде
бросаются
далее это попадает к вызывающему коду и
он пусть разбирается что с этим делать
но если дело дойдет до печати ошибки в
консоль
то запросто исключения тоже будут
распечатаны исключение в java делятся на
три группы это r exception-ы runtime
accusser если нарисовать как они
наследуются друг от друга то получится
следующая картинка
roll-a-ball
эра exception-ы
runtime xr fin air и подклассы это
ошибки виртуальные машины например out
of memory r означает что виртуальной
машине не хватило память но класс
default r означает что виртуальная
машина не смогла найти какой-то из
классов на который ссылается ваша
программа were fire означает что класс
найден но там что-то не так с байт кодом
живем таким образом сообщает что ей
стало плохо хотя и не на столько чтобы
сразу умереть общее у этих ошибок то что
если надо пытаться обрабатывать помочь
виртуальной машине вы скорее всего уже
не сможете exception-ы runtime exception
соответствует ошибкам уровня программы
некорректные параметры некорректное
состоянии
недопустимое действие ошибки такого
сорта можно уже пытаться как-то
обрабатывать
разница между ними состоит в том что
эксепшен его подклассы кроме runtime
exception являются проверяемыми чек
runtime exception-ы его подклассы
непроверяемыми anchor проверяем на
исключение являются предметом особого
контроля компилятора он внимательно
следить за тем чтобы такие исключения
декларировались и обрабатывались
характерный пример проверяемого
исключения и а эксепшен ошибка
ввода-вывода
если попытаться бросить такое исключение
как в этом примере так вот не скальпель
и руется компилятор будет требовать
чтобы либо в этом же методе был
обработчик этого исключения либо на
методе было явно написано что из него
может вылетать
его exception написать это можно
следующим образом
если мы напишем это на методе то
аналогичная проверка будет выполнено
компилятором и во всех местах вызова
нашего метода
то есть либо его эксепшен должен быть
сразу обработан либо возможность его
вылета обозначено в объявлениях всех
методов вызывающих наш метр
таким образом компилятор обеспечивает
что в сигнатуре метода видны все
проверяем и исключения которые могут из
него вылетать их может быть несколько
перечисленных через запятую
непроверяемые исключение такого внимания
компилятор и не получают их можно
свободно бросать из любой точки
программы не декларируют пример и
непроверяемых исключений этанал planter
exception эры index out of bounds
exception-ы арифметика exception
вылетающий при делении на 0 такие ошибки
могут случиться в любой точкой программы
и было бы крайне неудобно если бы
компилятор требовал их везде явно
декларировать или обрабатывать давайте
посмотрим как применить исключение к
нашему классу калькулятору заведем
специальный тип исключения который будет
соответствовать ошибкам вычисления
выражения отдельный тип исключения
позволит вызывающему году четко отличать
ошибки вычисления выражений вот других
ошибок в программе исключение
декларируется как обычный класс прямо
или косвенно на следующий цепь шин или
runtime exception зависимости от того
хотим мы делать его проверяемым или нет
делать исключение проверяемым или нет
дело вкуса и традиции конкретной группы
программистов есть лагерь выступающий за
проверяемое исключение и за
дополнительный контроль со стороны
компилятора другой лагерь говорит что
остальные популярные современные языки
программирования отказались от
проверяемых исключений потому что это не
лучшая идея а не загромождают и
усложняют корт а плохой не надежный код
можно написать несмотря ни на какие
проверки компилятора давайте сделаем
наше исключение не проверяем
исключение обычно заводят конструкторы
принимающие месяц и коз можно добавить
полили методов если они требуются теперь
в ответ на некорректное выражением
калькулятор будет бросать исключения
поскольку она не проверяемое то никаких
дополнительных слов в программе писать
не требуется а вот если бы мы сделали
его проверяемым то надо было бы
задекларировать его на уровне методы и
более того в интерфейсе калькулятор дело
в том что при наследовании или
реализации интерфейса нельзя
декларировать при определенному методу
больше проверяемых исключений чем
указано у базового метода
это нарушило бы контракт базового класса
зато контракт можно менять в другую
сторону бросать при определенном методе
меньше исключение чем задекларировано у
родителя кстати точка входа в программу
не тот моим может декларировать и
бросать любые проверяем и исключения все
что вылетит из него приведет к
распечатке с актриса и остановки
программ мы с вами обсудили что такое
исключение и как их бросать давайте
теперь научимся их обрабатывать в данном
примере мы в цикле читаем вводимые
пользователем выражениям и вычисляемых
случае ошибки выражения будем вежливо
просить пользователя повторить вот для
обработки исключений в языке есть
конструкция треки вич внутри трой блок
кода где могут случаться исключением а
далее один или более blog cash с классом
исключения
именем переменной куда мы сложим это
исключение на время обработки и
собственно ходом обработчика
чтобы не пугать пользователя stack trace
omi будем показывать ему только
текстовое сообщение из исключения внутри
catch блока видны те же идентификатор и
что и перед
а контрой а все что объявлена внутри
блока трой например вот этот резалт
скретч блоки уже не доступно если за
время работы трой блока исключение не
вылетела то блоки catch не исполняются
управление передается на вход после них
если исключение случилось и выполнился
catch блок то после него управления тоже
передается сюда же
блоков хочу одного трой может быть
несколько а не просматриваются в порядке
следования и выбирается первые с
подходящим типом исключением проверка
делается как на инстансов то есть с
точностью до подкласса например кетч от
exception
означает обработку любого типа
исключения проверяемого или не
проверяемого кроме ошибок джи-ви a catch
a trouble
поймает вообще все включая ошибки
виртуальные машины
выполнится может только 1 1 подходящий
блок вещь другие уже не будут
выполняться
начиная с java 7 стало возможно в одном
catch блоки обрабатывать несколько типов
исключений это удобно когда
исключение не являются под классами друг
друга но тем ни менее должны
обрабатываться одинаково после трой
может быть еще один блок finally
он выполнится в любом случае было
исключение или нет исполнился какой-то
течь блог или нет файл или исполняется
последнем в этом блоке обычно занимаются
освобождением ресурсов закрытием файлов
снятием блокировок файл или не является
обработчиком исключения то есть если из
блока троян вылетела исключения то после
отработки
блоков айна ли это исключение полетит
дальше это характерно часто
встречающаяся пример использования блока
3 5 но у него есть один недостаток
если блоки трой случилось исключение и
исключение так же случилось при вызове
клаус то дальше из этого блока полетит
исключения брошенная из клаус а исходная
будет потеряно поэтому можно встретить
еще такой партер исключение из клаус
здесь явно отлавливается
и игнорируется чтобы не перебивать
исходную ошибку это немного лучше но
тоже не очень красиво из-за того что
всем java разработчикам приходилось
как-то хитрить некрасиво выкручиваться
из этой ситуации с исключениями фай 0 до
7 была добавлена новая разновидность
thrive трой с ресурсами выглядит эта
конструкция следующим образом после
ключевого слова трой
в круглых скобках выделяются ресурсы с
которыми будет работать этот блок их
может быть несколько в таком случае они
перечисляются через точку с запятой
гарантируется что при выходе из блока
все ресурсы будут освобождены точнее что
на каждом из ресурсов будет вызван метод
клаус аналогично блоку файл или это
случится при любом раскладе
было исключение или не было но в отличие
от того премьера блока файл или которую
мы видели на предыдущих слайдах
здесь исключения из клаус не перебьет
собой исходное исключения а будет
добавлено у него в качестве заглушена во
so pleased to что реально происходит в
блоке thrice ресурсами можно
иллюстрировать следующем фрагментом кода
он может не передавать все нюансы но
демонстрирует идею кстати ресурс это
любой объект реализующий интерфейс java
link of the клаус оба в этом интерфейсе
всего один метод клаус это тот самый
метод который надо вызывать
для освобождения ресурса можно свободно
реализовывать этот интерфейс своих
собственных классах и тогда появится
возможность использовать их в блоке
thrice ресурсами обсудим теперь что
можно делать в блоке течь в ответ на
playman и исключения во первых нужно
ответить себе на вопрос
обладаем ли мы в данном месте программы
информации необходимой для принятия
решения о том как нужно реагировать на
исключением вполне возможно что нет в
таком случае правильным решением будет
пробросить это же или другое исключение
дальше вызывающему коду если мы решаем
пробросить то же самое исключение то и
блок tracked в этом месте программы
вообще не нужен пусть себе исключения
спокойно летит до того уровня где она
может быть нормально обработано
рассмотрим такой пример наша библиотека
калькулятор может своей реализации
использовать метод
dabu парс даблу для разбора чисел из
входного выражения если число оказалась
в некорректном формате тапор сдавал
бросает исключения намбер формат
exception
это означает ошибку выражение которую
нам надо сообщить коду вызвавшему
калькулятор по договоренности
калькулятор при проблемах с выражением
должен бросать калькулятор exception
поэтому нашем примере обработка намбер
фарматекс epson будет заключаться
заворачивание этого исключения в
калькулятор exception-ы выброси этого
нового исключения
зачем класть внутри нового исключения
исходное исключение для того чтобы при
печати
такого исключения был максимум
информации для разбора и так исключение
долетела до того места программы где
действительно достаточной информации для
принятия решения об обработке мы можем
решить что исключение фатальная им
немедленно завершить программу или
наоборот мы можем решить что исключение
безвредная на работоспособность
программы оно не повлияет
можно продолжать или как примере с
интерактивным калькулятором можем
попросить пользователя ввести другое
выражение правильная обработка зависит
от конкретной задачи но в любом случае
рекомендуется залакировать полную ошибку
со всем спектре сам чтобы упростить себе
в будущем разбор этой проблемы если
что-то пойдет не так
простых маленьких программах можно
просто распечатать ошибку в консоли
вызвав метод print stack trace
но лучше воспользоваться каким-то
специальным средством для планирования
это мы обсудим в следующем уроке
несколько рекомендаций по правильному
использованию с ключами когда вы пишете
какой-то метод вашем классе то подумайте
о том какие гарантии вы можете дать
вызывающим у вас коду можете ли вы дать
сильные гарантии то есть обещать что
несмотря на выброс исключения объект
останется в исходном корректном
состояние в нем ничего не сломается и
этим объектом можно пользоваться дальше
или вы можете дать слабые гарантии то
есть если состояние объекта и изменилось
то она осталась корректным и объектом
можно пользоваться дальше возможно вы
гарантируете только то что несмотря на
исключение не случилось утечек ресурсов
а объекта к использованию уже не
пригоден
но и в худшем случае вы не можете
гарантировать ничего из
вышеперечисленного конечно чем более
сильные гарантии вы можете обеспечить
тем удобнее другим программистом будет
пользоваться вашим классом к этому стоит
стремиться гарантия отсутствие утечек
можно обеспечить правильным
использованием блока втрой fine или и
трой с ресурсами а чтобы объект не
переходила некорректное состояние можно
например сначала тщательного лидирует
все входные параметры метода или если в
методы делается какое-то многоэтапные
вычисления
то промежуточные результаты этих
вычислений сохранять сначала в локальных
переменных и только когда все вычисление
успешно отработало то менять состояние
объекта присваивая новое значение его
поля и второе замечание механизм
обработки исключений тропе
следует применять для действительно
исключительных ситуаций не надо пытаться
реализовывать обычную условную логику
при помощи тратят во первых это менее
эффективно порождение обработка
исключений несут ненулевым накладные
расходы во вторых можно случайно
обработать не ту ошибку которую вы
хотели если втрое блоки происходит много
всего вот это
плохой пример так делать не норы вместо
этого надо использовать обычный условный
оператор
кстати скажу по секрету есть утилит ный
method of just the string принимающий
объект который реализует ровно вот эту
логику
поэтому здесь можно использовать его
классов дпс находится в пакете java util
предыдущем уроке
обсуждая обработка исключений мы с вами
говорили о том что полезно сохранить
куда-то исключение с полным спектре сам
для последующего разбора
это не единственный случай когда она
может захотеться из программы сохранить
какое-то диагностическое сообщение на
будущее
например при отладке какого-то сложного
алгоритма мы можем захотеть увидеть
подробный протокол работы программы
вплоть до того что вызвался такое-то
метод с такими параметрами или в
такую-то переменную записано такое это
значение или вот еще пример программа
сервер может выводить диагностическое
сообщение каждый раз когда и приходит
клиентский запрос так мы можем собирать
статистику о том какие клиенты сколько
раз с каких адресов
присылали нам запросы и сколько
миллисекунд
заняла обработка каждого запроса такие
вещи можно конечно писать посты draught
или стр но есть способ лучше
стандартной библиотеки java есть набор
классов для организации логирования и
воспользовавшись ими мы автоматически
получаем следующее бонусы
во-первых точечную настройку логирования
включение и отключения на уровне
отдельных пакетов или класса во вторых
настройку уровня детальности логирования
в третьих настройка место куда логе
будут писаться и в четвертых настройка
форматов которым этиологии будут вестись
причем это может удобно настраиваться в
конфигурационном файле
то есть запустили программу с одними
параметрами получили полный отладочный
протокол всего что внутри программы
происходило
запустили программу с другими
параметрами получили режим промышленной
эксплуатации в котором программа
за лоббировала начали какую-то важную
информацию например параметры с которыми
она запущена а потом она не будет писать
ничего лишнего пока все идет нормально
для того чтобы получить такое гибкое
логирование
программе даже не нужен ни один из
достаточно правильно воспользоваться
теми средствами который предоставляет
нам стандартная библиотека
эти замечательные классы лежат в пакете
джалла util logging основной класс
логгер
именно через него наша программа будет
писать лагер лагер можно получить вызвал
статический метод get ломбер этот метод
возвращает нам лагерь с указанным именем
обычная практика в каждом классе где
требуется логирования зависти и
финальное статическое поле
куда положить лагерь с именем
соответствующем полному имени класса в
данном примере у нас получится лагер с
именем парк степик java logging лог тема
такая практика с именованием лагер в
честь классов программы не случайно во
первых каждый класс получает свой
индивидуальный логгер и появляется
возможность управлять настройками
логирования с точностью до класса для 1
класса логирования включена ли соседнего
выключена во вторых благодаря длинным
именам разделенным точками блогеры
выстраиваются в иерархию в соответствии
семинаре в данном примере у нас есть
логгер класс лог дима соответствующим
именем а также блогеры родители с
именами works ты как java logging орг
степик java
арк степик арк и самый верхний корневой
лагерь с именем пустой строкой обработка
лагер у им их сообщений идет от
конкретного логгера
через которые сообщение вброшена наверх
к корню и на каждом уровне может быть
какая-то своя обработка например на
уровне work степик можно организовать
вывод всех событий в какой-то
специальный лог-файл на корневом уровне
можно только выводить в консоль самые
критические ошибки и так мы получили
логгер для текущего класса
давайте залакируем через него
какое-нибудь сообщение
это делается следующим образом вот гора
есть метод с говорящим названием лук
первым параметром этот метод принимает
леру
уровень логирования это степень
серьезности данного сообщения
инфу это информационное сообщение о
нормальном ходе исполнения программы
есть два более серьезных уровням и 4
менее серьезных на уровне св
блокируются серьезной ошибки программу
это когда совсем ужас ужас на уровне
варнинг
блокируются предупреждение конфиг
предназначен для логирования каких-то
конфигурационных параметров a fine liner
файнест
для совсем детального логирования что
программа делает
вплоть до входа выхода в методы и прочих
мелочей для удобства на каждый уровень
логирования в лагере есть одноименный
метод он выбрасывает сообщение
соответствующего уровня
логгер можно сконфигурировать таким
образом чтобы он игнорировал все
сообщения с уровнем ниже заданного
например лагер настроенный на уровне
warning будет принимать только сообщение
с уровне на север и варнинг
и тихонько отправлять где гнул все
остальное настройка делается либо в коде
при помощи вызова метода силу
либо в конфигурационном файле часто
нужно залакировать не просто статическую
строчку а добавить туда какую-то
динамическую информацию например
значения параметров метода или текущее
состояние объекта это можно сделать
двумя способами первый очевидный способ
конкатенировать все что нам нужную
строку и передать результат метод лук у
этого подхода есть один недостаток
проявляющийся в программах работающих
под большой нагрузкой даже если
логирование данного уровня отключена все
равно программа постоянно будет
заниматься конкатенации строк и тратить
на это заметно и время поэтому был
придумать другой способ
передавайте метод лоб фиксированную
строку в которой специальным образом
обозначенным местам для подстановки и
отдельно передавать значения которые
будут туда подставляться если значение
одно то она передается непосредственно а
если их несколько то нужно завернуть их
в массив объектов
подстановка параметров строку происходит
внутри логгера и только при условии что
указанный уровень логирования включен то
есть строчка действительно попадет в лог
а не будет выкинуто отдельно поддержан
случай когда требуется получить в логе
распечатку stack trace исключения для
этого достаточно передать в лог
исключение третьем параметрам символы
подстановки в сообщений при этом не
нужны кстати тот факт что в лагерь
передаются только константные строки с
местами для подстановки позволяет делать
локализацию
то есть перевод лагер у им их сообщений
на любой язык при этом лаггеру внутри
себя будет использовать строчку как ключ
для поиска перевода
словаре разумеется такой словарь вы
должны будете предоставить джалла не
настолько сурова чтобы делать
автоматический машинный перевод
любого текста на любой язык если перевод
не будет найден то переданная строчка
используются как есть
если копнуть чуть глубже в реализацию
логирования то мы увидим что лагер
не сам решает как именно он должен
обрабатывать пришедшие сообщений
он делегирует это решение другому
объекту
хендлер у хендлер это абстрактный класс
которого стандартной библиотеке есть три
конкретных наследника это консоль
хендлер выводящие сообщение в консоль
file finder лагер у ющий файл и socker
хендлер отправляющие лог-сообщение
посети хендлер задается в конфигурации
или прикрепляется к лаггеру
вызовом метода логгера этот хендлер и
еще один аспект в каком формате
сообщение записывается в лоб за это
отвечает еще один объект форман тир
хендлер имеет ссылку на формате и
делегирует ему всю работу по превращению
за лакированного сообщения в
окончательный вид пригодный к выводу
файл или передачи по сети
стандартной библиотеке есть две
реализации simple формате выводящий все
более-менее человека читаемым текстовом
виде и xml формате производящей машина
читаемый лоб формате xml
комбинируя логгеры и хендлеры и формат
терры можно гибко настраивать что куда и
как программа будет писать к тому же
можно реализовать свой собственный
хендлер или формате если стандартные не
подходят
давайте рассмотрим работу с лагерями на
примере небольшой демонстрационной
программы эта программа детально лаги
рует все что не происходит на делает это
на уровне fine и только в случае
серьезной ошибки она за лаги рует
исключение уметь из аспект рейсом на
уровне сивир если запустить эту
программу то мы увидим следующее
в случае ошибки она за лаги рует ft
stack trace исключение или в случае если
ничего не произошло то они заблокируют
ничего то что она лагера вала на уровне
фай влоги не появляется это потому что
по умолчанию логгер настроен на уровень
info
то есть он молча игнорирует все что
приходит ему на более детальных уровнях
например файл это поведение можно
переопределить в конфликт файле
он может выглядеть например следующим
образом здесь мы включаем специальный
уровень логирования а у которая
разрешает
видеть записи на абсолютно всех уровнях
самый подробный лог не кроме того мы
говорим что вывод будет идти в консоль
за это отвечает консоль хендлер зачем
нам явно говорить что вывод должен идти
в консоль мы ведь и так его уже видели в
консоли дело в том что если запустить
виртуальную машину с перри определенном
конфигом логирование то все стандартные
настройки аннулируются если здесь в
нашем конфиге явно не указать этот
хендлер то лог-сообщения никуда не
попадут поэтому мы его явно указываем
чтобы запустить виртуальную машину с
нашими настройками логирования нужно
передать ей вот такой специальный
параметр сейчас мы это сделаем
и если теперь запустить нашу программу
то вуаля мы получили полный лог самой
детальной в том числе сообщения уровня
flame
